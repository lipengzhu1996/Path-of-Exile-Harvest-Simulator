# -*- coding: utf-8 -*-
"""Path of Exile Harvest.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/16sh0letc6Gbib4qZ3zMYTkbopF0KkkUJ
"""

# Settings

from enum import Enum
from scipy.stats import norm
import numpy as np
import random
import matplotlib.pyplot as plt

import itertools
from itertools import permutations

ENABLE_DEBUG = False

ENABLE_CROP_ROTATION = True

class PlotColor(Enum):
    YELLOW = 0
    BLUE = 1
    PURPLE = 2

# Lifeforce market price per Chaos
YELLOW_LIFEFORCE_VALUE = 1/23
BLUE_LIFEFORCE_VALUE = 1/62
PURPLE_LIFEFORCE_VALUE = 1/67

# Probability of upgrading the seed from T1 to T2, T2 to T3, T3 to T4
T1_UPGRADE_PROB = 0.25
T2_UPGRADE_PROB = 0.2
T3_UPGRADE_PROB = 0.03

# T2 T3 T4 seeds generation follows binomial distribution if crop rotation is disabled
# LOW CONFIDNECE
T2_GEN_BINOMIAL_N = 8
T2_GEN_BINOMIAL_P = 0.75
T3_GEN_BINOMIAL_N = 3
T3_GEN_BINOMIAL_P = 0.25 * 1.1 # Atlas passives of “Harvest Crops in your Maps have 10% increased chance to contain Tier 3 Plants”
T4_GEN_BINOMIAL_N = 1
T4_GEN_BINOMIAL_P = 0.01 * 1.6 # Atlas passives of “Harvest Crops in your Maps have 60% increased chance to contain Tier 4 Plants”

# Lifefore drop rate from T1, T2, etc. monsters
T1_DROP_RATE = 0.02
T2_DROP_RATE = 0.1
T3_DROP_RATE = 1
T4_DROP_RATE = 1

# Lifefore amount from T1, T2, etc. monsters
T1_DROP_AMOUNT = 7.25
T2_DROP_AMOUNT = 18.5
T3_DROP_AMOUNT = 47
T4_DROP_AMOUNT = 230

# Seed to value map based on the information above
T1_VALUE_MAP = {
    PlotColor.YELLOW: T1_DROP_RATE * T1_DROP_AMOUNT * YELLOW_LIFEFORCE_VALUE,
    PlotColor.BLUE: T1_DROP_RATE * T1_DROP_AMOUNT * BLUE_LIFEFORCE_VALUE,
    PlotColor.PURPLE: T1_DROP_RATE * T1_DROP_AMOUNT * PURPLE_LIFEFORCE_VALUE,
}

T2_VALUE_MAP = {
    PlotColor.YELLOW: T2_DROP_RATE * T2_DROP_AMOUNT * YELLOW_LIFEFORCE_VALUE,
    PlotColor.BLUE: T2_DROP_RATE * T2_DROP_AMOUNT * BLUE_LIFEFORCE_VALUE,
    PlotColor.PURPLE: T2_DROP_RATE * T2_DROP_AMOUNT * PURPLE_LIFEFORCE_VALUE,
}

T3_VALUE_MAP = {
    PlotColor.YELLOW: T3_DROP_RATE * T3_DROP_AMOUNT * YELLOW_LIFEFORCE_VALUE,
    PlotColor.BLUE: T3_DROP_RATE * T3_DROP_AMOUNT * BLUE_LIFEFORCE_VALUE,
    PlotColor.PURPLE: T3_DROP_RATE * T3_DROP_AMOUNT * PURPLE_LIFEFORCE_VALUE,
}

T4_VALUE_MAP = {
    PlotColor.YELLOW: T4_DROP_RATE * T4_DROP_AMOUNT * YELLOW_LIFEFORCE_VALUE,
    PlotColor.BLUE: T4_DROP_RATE * T4_DROP_AMOUNT * BLUE_LIFEFORCE_VALUE,
    PlotColor.PURPLE: T4_DROP_RATE * T4_DROP_AMOUNT * PURPLE_LIFEFORCE_VALUE,
}

# Weight of generating 3, 4, or 5 crops in the harvest
THREE_CROPS_WEIGHT = 0.3
FOUR_CROPS_WEIGHT = 0.5
FIVE_CROPS_WEIGHT = 0.2

# Probability of wilting
PLANT_WILT_PROB = 0.4

# Weight of generating yellow, blue or purple seeds in the plot
YELLOW_SEED_WEIGHT = 1
BLUE_SEED_WEIGHT = 0.55
PURPLE_SEED_WEIGHT = 0.55

# Data structure
# One Harvest has 3-5 Crops, and each Crop has 2 Plots

class Plot:
    def __init__(self, color: PlotColor, t1_count, t2_count, t3_count, t4_count):
        self.color: PlotColor = color
        self.t1_count = t1_count
        self.t2_count = t2_count
        self.t3_count = t3_count
        self.t4_count = t4_count

        self.total_value = self.get_total_value()

    def get_total_value(self):
        return T1_VALUE_MAP[self.color] * self.t1_count + T2_VALUE_MAP[self.color] * self.t2_count + T3_VALUE_MAP[self.color] * self.t3_count + T4_VALUE_MAP[self.color] * self.t4_count

    def print_debug(self):
        print(f"color: {self.color}, t1_count: {self.t1_count}, t2_count: {self.t2_count}, t3_count: {self.t3_count}, t4_count: {self.t4_count}, total_value: {self.total_value}")

class Crop:
    def __init__(self, plots: list[Plot]):
        self.plots: list[Plot] = plots

class Harvest:
    def __init__(self, crops: list[Crop]):
        self.crops: list[Crop] = crops
        self.total_crop_count: int = len(crops)

    def simulate_harvest(self, harvest_order: list[list[int]]):
        # [[0,0], [0,1], [1,1], [1,0], [2,0], [2,1]]
        total_return = 0
        crop_harvested = []

        for harvest_step_i in range(len(harvest_order)):
            plot_to_harvest_id = harvest_order[harvest_step_i]

            # If current harvest step is None, it means the plot here is wilted, skip
            if plot_to_harvest_id == None or len(plot_to_harvest_id) != 2:
                continue

            # Harvest, add value to total return
            plot_to_harvest = self.crops[plot_to_harvest_id[0]].plots[plot_to_harvest_id[1]]
            harvest_value = plot_to_harvest.total_value
            total_return += harvest_value
            if ENABLE_DEBUG:
                print("==============================")
                print(f"{plot_to_harvest_id} is harvested, added {harvest_value} return")

            # Simulate if the pair plot will wilt. If so remove the pair plot from the harvest order (set to None)
            is_pair_plot_wilted = plot_wilt_simulated()
            if is_pair_plot_wilted:
                for wilt_step_i in range(harvest_step_i + 1, len(harvest_order)):
                    if harvest_order[wilt_step_i] != None and harvest_order[wilt_step_i][0] == plot_to_harvest_id[0]:
                        harvest_order[wilt_step_i] = None
                        if ENABLE_DEBUG:
                            print(f"pair plot wilted, new harvest order: {harvest_order}")

            # If crop rotation is disabled, seeds will not be upgraded
            if not ENABLE_CROP_ROTATION:
                continue

            # Upgrade all other different color plots left
            for plot_upgrade_i in range(harvest_step_i, len(harvest_order)):
                plot_to_upgrade_id = harvest_order[plot_upgrade_i]
                if plot_to_upgrade_id == None or len(plot_to_upgrade_id) != 2:
                    continue

                if self.crops[plot_to_upgrade_id[0]].plots[plot_to_upgrade_id[1]].color != plot_to_harvest.color:
                    self.crops[plot_to_upgrade_id[0]].plots[plot_to_upgrade_id[1]] = plot_upgrade_simulated(self.crops[plot_to_upgrade_id[0]].plots[plot_to_upgrade_id[1]])
                    if ENABLE_DEBUG:
                        print(f"crops {plot_to_upgrade_id} upgraded")
                        self.crops[plot_to_upgrade_id[0]].plots[plot_to_upgrade_id[1]].print_debug()

        if ENABLE_DEBUG:
            print(f"total return: {total_return}")
        return total_return

    def print_debug(self):
        print(f"total_crop_count: {self.total_crop_count}")
        for i in range(self.total_crop_count):
            print(f"crop {i}:")
            self.crops[i].plots[0].print_debug()
            self.crops[i].plots[1].print_debug()

def plot_upgrade_simulated(old_plot: Plot) -> Plot:
    t1_to_t2_count = np.random.binomial(old_plot.t1_count, T1_UPGRADE_PROB)
    t2_to_t3_count = np.random.binomial(old_plot.t2_count, T2_UPGRADE_PROB)
    t3_to_t4_count = np.random.binomial(old_plot.t3_count, T3_UPGRADE_PROB)

    new_plot = Plot(old_plot.color, old_plot.t1_count - t1_to_t2_count, old_plot.t2_count + t1_to_t2_count - t2_to_t3_count, old_plot.t3_count + t2_to_t3_count - t3_to_t4_count, old_plot.t4_count + t3_to_t4_count)
    return new_plot

def plot_upgrade_expected(old_plot: Plot) -> Plot:
    t1_to_t2_count = old_plot.t1_count * T1_UPGRADE_PROB
    t2_to_t3_count = old_plot.t2_count * T2_UPGRADE_PROB
    t3_to_t4_count = old_plot.t3_count * T3_UPGRADE_PROB

    new_plot = Plot(old_plot.color, old_plot.t1_count - t1_to_t2_count, old_plot.t2_count + t1_to_t2_count - t2_to_t3_count, old_plot.t3_count + t2_to_t3_count - t3_to_t4_count, old_plot.t4_count + t3_to_t4_count)
    return new_plot

def plot_wilt_simulated() -> bool:
    return random.choices([1, 0], weights=[PLANT_WILT_PROB, 1 - PLANT_WILT_PROB])[0] == 1

# Generation of the sacred grove and harvest order

def generate_plot() -> Plot:
    seed_color = random.choices([PlotColor.YELLOW, PlotColor.BLUE, PlotColor.PURPLE], weights=[YELLOW_SEED_WEIGHT, BLUE_SEED_WEIGHT, PURPLE_SEED_WEIGHT])[0]

    # Only T1 seeds will be generated if crop rotation is enabled
    if ENABLE_CROP_ROTATION:
        return Plot(seed_color, 23, 0, 0, 0)

    t2_count = np.random.binomial(T2_GEN_BINOMIAL_N, T2_GEN_BINOMIAL_P)
    t3_count = np.random.binomial(T3_GEN_BINOMIAL_N, T3_GEN_BINOMIAL_P)
    t4_count = np.random.binomial(T4_GEN_BINOMIAL_N, T4_GEN_BINOMIAL_P)
    t1_count = 23 - t2_count - t3_count - t4_count
    return Plot(seed_color, t1_count, t2_count, t3_count, t4_count)


def generate_harvest() -> Harvest:
    # Generate crops
    crops_num = random.choices([3, 4, 5], weights=[THREE_CROPS_WEIGHT, FOUR_CROPS_WEIGHT, FIVE_CROPS_WEIGHT])[0]

    harvest = []
    # For each crop, generate the plots
    for i in range(crops_num):
        plot1 = generate_plot()
        plot2 = generate_plot()
        crop = Crop([plot1, plot2])
        harvest.append(crop)

    return Harvest(harvest)

def generate_harvest_order(harvest: Harvest) -> list[list[int]]:
    harvest_order = []

    # Map is generated randomly so the harvest order can be fixed [[0,0], [0,1], [1,0], [1,1], [2,0], [2,1], ...]
    for i in range(harvest.total_crop_count):
        harvest_order.append([i, 0])
        harvest_order.append([i, 1])
    return harvest_order

# Simulation
ENABLE_CROP_ROTATION_COMPENSTAE = True
value_result = []

for i in range(100000):
    harvest = generate_harvest()
    harvest_order = generate_harvest_order(harvest)
    value = harvest.simulate_harvest(harvest_order)
    value_result.append(value)

if ENABLE_CROP_ROTATION and ENABLE_CROP_ROTATION_COMPENSTAE:
    p15 = np.percentile(value_result, 15)
    value_result = [x for x in value_result if x >= p15]

mu, std = norm.fit(value_result)
print(f"mu: {mu}, std: {std}")

plt.hist(value_result, bins=25, density=True, alpha=0.6, color='b')
xmin, xmax = plt.xlim()
x = np.linspace(xmin, xmax, 100)
p = norm.pdf(x, mu, std)
plt.plot(x, p, 'k', linewidth=2)
title = "Fit results: mu = %.2f,  std = %.2f" % (mu, std)
plt.title(title)

plt.show()

# All possible harvests - Combination with Replacement problem
# One harvest has 3-5 crops, and each crop has 0-2 yellow plots

ENABLE_CROP_ROTATION = True
PLANT_WILT_PROB = 0.4

# Generate all possible combinations given n (number of yellow plots: 0,1,2) and r (number of crops: 1,2,3)
# For example 3 Crops: [0, 0, 0], [0, 0, 1], [0, 0, 2], [0, 1, 1], [0, 1, 2], [0, 2, 2], [1, 1, 1], [1, 1, 2], [1, 2, 2], [2, 2, 2]
# Each one represents a possible harvest
def generate_combinations_with_replacement(n, r):
    elements = list(range(n))
    return list(itertools.combinations_with_replacement(elements, r))

def generate_harvest (num_of_yellow_in_crop: list[int]) -> Harvest:
    crops = []
    # For each crop, generate the plots
    for i in num_of_yellow_in_crop:
        if i == 0:
            plot1 = Plot(PlotColor.BLUE, 23, 0, 0, 0)
            plot2 = Plot(PlotColor.BLUE, 23, 0, 0, 0)
        elif i == 1:
            plot1 = Plot(PlotColor.BLUE, 23, 0, 0, 0)
            plot2 = Plot(PlotColor.YELLOW, 23, 0, 0, 0)
        else:
            plot1 = Plot(PlotColor.YELLOW, 23, 0, 0, 0)
            plot2 = Plot(PlotColor.YELLOW, 23, 0, 0, 0)
        crop = Crop([plot1, plot2])
        crops.append(crop)

    return Harvest(crops)

def generate_all_harvest_order(number_of_crops: int) -> list[list[int]]:
    harvest_order = []
    for i in range(number_of_crops):
        harvest_order.append([i, 0])
        harvest_order.append([i, 1])

    return list(permutations(harvest_order))


def run_simulations(harvest_yellow_list: list[int]):
    print(f"Harvest: {harvest_yellow_list}")
    harvest_order = generate_all_harvest_order(len(harvest_yellow_list))

    result = []
    for order in harvest_order:
        values = []

        for i in range(1000):
            new_order = list(order)
            harvest = generate_harvest(harvest_yellow_list)
            value = harvest.simulate_harvest(new_order)
            values.append(value)

        total_value = np.mean(values)
        result.append((order, total_value))

    result.sort(key=lambda x: x[1], reverse=True)
    print(result)

def run_simulations_with_order(harvest_yellow_list: list[int], harvest_order: list[list[int]]):
    values = []

    for i in range(10000):
        new_order = list(harvest_order)
        harvest = generate_harvest(harvest_yellow_list)
        value = harvest.simulate_harvest(new_order)
        values.append(value)

    total_value = np.mean(values)
    print(total_value)

"""# 结论：
1. 如果使用觉醒圣甲虫 （枯萎概率40%），一定要轮作。
 * 三块田：不管颜色如何分布，先无脑收割蓝紫，最后收割黄（即使黄色有概率枯萎）。如果只有一块蓝紫，先收割黄再收割蓝紫。
 * 四五块田：前四块收割蓝紫，之后无脑收割黄色。如果生成的蓝紫小于三块，先收割黄再收割蓝紫

2. 如果不使用觉醒圣甲虫 （枯萎概率90%），最好不点轮作。如果非要轮作，不考虑不枯萎的概率：
 * 三块田：最好直接走，如果非要打，最少的颜色留一个最后收割
 * 四块田：优先升级，留一个黄色确保收割即可
 * 五块田：优先升级，留两个黄色确保收割即可

"""

# All possible harvests with 3 crops: [0, 0, 0], [0, 0, 1], [0, 0, 2], [0, 1, 1], [0, 1, 2], [0, 2, 2], [1, 1, 1], [1, 1, 2], [1, 2, 2], [2, 2, 2]

run_simulations([0, 0, 0])

# 蓝蓝，蓝蓝，蓝蓝
# 直接走

# All possible harvests with 3 crops: [0, 0, 0], [0, 0, 1], [0, 0, 2], [0, 1, 1], [0, 1, 2], [0, 2, 2], [1, 1, 1], [1, 1, 2], [1, 2, 2], [2, 2, 2]

run_simulations([0, 0, 1])

# 蓝蓝，蓝蓝，蓝黄
# 先收割所有蓝再收割黄，收割顺序无所谓

ENABLE_DEBUG = True

harvest = [0, 0, 1]
harvest = generate_harvest(harvest)

harvest_order = [[1, 1], [1, 0], [2, 0], [0, 1], [0, 0], [2, 1]]

harvest.simulate_harvest(harvest_order)

ENABLE_DEBUG = False

# All possible harvests with 3 crops: [0, 0, 0], [0, 0, 1], [0, 0, 2], [0, 1, 1], [0, 1, 2], [0, 2, 2], [1, 1, 1], [1, 1, 2], [1, 2, 2], [2, 2, 2]

run_simulations([0, 0, 2])

# 蓝蓝，蓝蓝，黄黄
# 先收割所有蓝再收割黄，收割顺序无所谓

# All possible harvests with 3 crops: [0, 0, 0], [0, 0, 1], [0, 0, 2], [0, 1, 1], [0, 1, 2], [0, 2, 2], [1, 1, 1], [1, 1, 2], [1, 2, 2], [2, 2, 2]

run_simulations([0, 1, 1])

# 蓝蓝，蓝黄，蓝黄
# 先收割所有蓝再收割黄，收割顺序无所谓

# All possible harvests with 3 crops: [0, 0, 0], [0, 0, 1], [0, 0, 2], [0, 1, 1], [0, 1, 2], [0, 2, 2], [1, 1, 1], [1, 1, 2], [1, 2, 2], [2, 2, 2]

run_simulations([0, 1, 2])

# 蓝蓝，蓝黄，黄黄
# 先收割所有蓝再收割黄，收割顺序无所谓

# All possible harvests with 3 crops: [0, 0, 0], [0, 0, 1], [0, 0, 2], [0, 1, 1], [0, 1, 2], [0, 2, 2], [1, 1, 1], [1, 1, 2], [1, 2, 2], [2, 2, 2]

run_simulations([0, 2, 2])

# 蓝蓝，黄黄，黄黄
# 先收割所有蓝再收割黄，收割顺序无所谓

# All possible harvests with 3 crops: [0, 0, 0], [0, 0, 1], [0, 0, 2], [0, 1, 1], [0, 1, 2], [0, 2, 2], [1, 1, 1], [1, 1, 2], [1, 2, 2], [2, 2, 2]

run_simulations([1, 1, 1])

# 蓝黄，蓝黄，蓝黄
# 先收割所有蓝再收割黄，收割顺序无所谓

# All possible harvests with 3 crops: [0, 0, 0], [0, 0, 1], [0, 0, 2], [0, 1, 1], [0, 1, 2], [0, 2, 2], [1, 1, 1], [1, 1, 2], [1, 2, 2], [2, 2, 2]

run_simulations([1, 1, 2])

# 蓝黄，蓝黄，黄黄
# 先收割所有蓝再收割黄，收割顺序无所谓

# All possible harvests with 3 crops: [0, 0, 0], [0, 0, 1], [0, 0, 2], [0, 1, 1], [0, 1, 2], [0, 2, 2], [1, 1, 1], [1, 1, 2], [1, 2, 2], [2, 2, 2]

run_simulations([1, 2, 2])

# 蓝黄，黄黄，黄黄
# 先收割所有黄再收割蓝，收割顺序无所谓，或者直接走

# All possible harvests with 3 crops: [0, 0, 0], [0, 0, 1], [0, 0, 2], [0, 1, 1], [0, 1, 2], [0, 2, 2], [1, 1, 1], [1, 1, 2], [1, 2, 2], [2, 2, 2]

run_simulations([2, 2, 2])

# 黄黄，黄黄，黄黄
# 直接走

# All possible harvests with 4 crops: [0, 0, 0, 0], [0, 0, 0, 1], [0, 0, 0, 2], [0, 0, 1, 1], [0, 0, 1, 2]...

# 优先升级黄色
run_simulations_with_order([0, 0, 1, 1], [[0, 0], [0, 1], [1, 0], [1, 1], [2, 0], [3, 0], [2, 1], [3, 1]])

# 优先收割黄色
run_simulations_with_order([0, 0, 1, 1], [[0, 0], [0, 1], [1, 0], [1, 1], [2, 1], [3, 1], [2, 0], [3, 0]])

# 蓝蓝，蓝蓝，蓝黄，蓝黄
# 还是先收割所有蓝色最后收割黄色

# All possible harvests with 4 crops: [0, 0, 0, 0], [0, 0, 0, 1], [0, 0, 0, 2], [0, 0, 1, 1], [0, 0, 1, 2]...

# 优先升级黄色
run_simulations_with_order([0, 0, 0, 1], [[0, 0], [0, 1], [1, 0], [1, 1], [2, 0], [2, 1], [3, 0], [3, 1]])

# 优先收割黄色
run_simulations_with_order([0, 0, 0, 1], [[0, 0], [0, 1], [1, 0], [1, 1], [2, 0], [2, 1], [3, 1], [3, 0]])

# 蓝蓝，蓝蓝，蓝蓝，蓝黄
# 情况开始变化，最后一组要先收割黄色
# 说明升级黄色种子的收益开始边际递减，升级的收益无法抵消枯萎的风险
# 并且与上一组对照试验说明一个黄色种子升级多一次不如多一个黄色种子

# All possible harvests with 5 crops: [0, 0, 0, 0, 0], [0, 0, 0, 0, 1], [0, 0, 0, 0, 2], [0, 0, 0, 1, 1], [0, 0, 0, 1, 2]...

# 优先升级黄色
run_simulations_with_order([0, 0, 0, 1, 1], [[0, 0], [0, 1], [1, 0], [1, 1], [2, 0], [2, 1], [3, 0], [4, 0], [3, 1], [4, 1]])

# 优先收割黄色
run_simulations_with_order([0, 0, 0, 1, 1], [[0, 0], [0, 1], [1, 0], [1, 1], [2, 0], [2, 1], [3, 1], [4, 1], [4, 0], [4, 0]])

# 蓝蓝，蓝蓝，蓝蓝，蓝黄，蓝黄
# 最后两组都要先收割黄

# All possible harvests with 5 crops: [0, 0, 0, 0, 0], [0, 0, 0, 0, 1], [0, 0, 0, 0, 2], [0, 0, 0, 1, 1], [0, 0, 0, 1, 2]...

run_simulations_with_order([0, 0, 0, 0, 1], [[0, 0], [0, 1], [1, 0], [1, 1], [2, 0], [2, 1], [3, 0], [3, 1], [4, 0], [4, 1]])

run_simulations_with_order([0, 0, 0, 0, 1], [[0, 0], [0, 1], [1, 0], [1, 1], [2, 0], [2, 1], [3, 0], [3, 1], [4, 1], [4, 0]])

# 蓝蓝，蓝蓝，蓝蓝，蓝蓝，蓝黄
# 最后一组要先收割黄

# All possible harvests with 5 crops: [0, 0, 0, 0, 0], [0, 0, 0, 0, 1], [0, 0, 0, 0, 2], [0, 0, 0, 1, 1], [0, 0, 0, 1, 2]...

run_simulations_with_order([0, 0, 0, 1, 2], [[0, 0], [0, 1], [1, 0], [1, 1], [2, 0], [2, 1], [3, 0], [3, 1], [4, 0], [4, 1]])

run_simulations_with_order([0, 0, 0, 1, 2], [[0, 0], [0, 1], [1, 0], [1, 1], [2, 0], [2, 1], [3, 1], [3, 0], [4, 0], [4, 1]])

# 平衡点：大概收割完前三组蓝色之后，选择先收割黄色和再升级一次黄色的收益基本相当

# All possible harvests with 5 crops: [0, 0, 0, 0, 0], [0, 0, 0, 0, 1], [0, 0, 0, 0, 2], [0, 0, 0, 1, 1], [0, 0, 0, 1, 2]...

# 先收割蓝
run_simulations_with_order([0, 1, 2, 2, 2], [[0, 0], [0, 1], [1, 0], [1, 1], [2, 0], [2, 1], [3, 0], [3, 1], [4, 0], [4, 1]])

# 先收割黄
run_simulations_with_order([0, 1, 2, 2, 2], [[1, 1], [2, 0], [2, 1], [3, 0], [3, 1], [4, 0], [4, 1], [1, 0], [0, 1], [1, 0]])

# 基本平衡，如果有三块蓝紫的情况下需要先收割黄

# Create data points for x
x = np.linspace(0, 8, 100)

# Define the quadratic function (e.g., y = -x^2 + 2x + 1)
def quadratic(x):
  return -x**2 + 8*x

# Calculate corresponding y values
y = quadratic(x)

# Create the plot
plt.plot(x, y)
plt.xlabel("blue seeds harvested")
plt.ylabel("value expected")
plt.title("Expectation")
plt.grid(True)

# Show the plot
plt.show()

# 无觉醒圣甲虫
PLANT_WILT_PROB = 0.9

# All possible harvests with 3 crops: [0, 0, 0], [0, 0, 1], [0, 0, 2], [0, 1, 1], [0, 1, 2], [0, 2, 2], [1, 1, 1], [1, 1, 2], [1, 2, 2], [2, 2, 2]
run_simulations([0, 1, 1])

# 蓝蓝，蓝黄，蓝黄
# 收割两块地里的蓝色，然后收割黄色

# All possible harvests with 3 crops: [0, 0, 0], [0, 0, 1], [0, 0, 2], [0, 1, 1], [0, 1, 2], [0, 2, 2], [1, 1, 1], [1, 1, 2], [1, 2, 2], [2, 2, 2]
run_simulations([0, 1, 2])

# 蓝蓝，蓝黄，黄黄
# 收割所有蓝色，然后收割黄色

# All possible harvests with 4 crops: [0, 0, 0, 0], [0, 0, 0, 1], [0, 0, 0, 2], [0, 0, 1, 1], [0, 0, 1, 2]...

# 收割四次蓝色
run_simulations_with_order([0, 0, 1, 1], [[0, 0], [0, 1], [1, 0], [1, 1], [2, 0], [3, 0], [2, 1], [3, 1]])

# 收割两次蓝色
run_simulations_with_order([0, 0, 1, 1], [[0, 0], [0, 1], [1, 0], [1, 1], [2, 1], [3, 1], [2, 0], [3, 0]])

# 收割三次蓝色
run_simulations_with_order([0, 0, 1, 1], [[0, 0], [0, 1], [1, 0], [1, 1], [2, 0], [3, 1], [2, 1], [3, 0]])

# 收割四次蓝色
run_simulations_with_order([0, 0, 1, 1], [[0, 0], [0, 1], [1, 0], [1, 1], [2, 0], [3, 0], [2, 1], [3, 1]])

# 蓝蓝，蓝蓝，蓝黄，蓝黄
# 优先升级，确保至少收割一个黄色

# All possible harvests with 4 crops: [0, 0, 0, 0], [0, 0, 0, 1], [0, 0, 0, 2], [0, 0, 1, 1], [0, 0, 1, 2]...

# 收割一次蓝色
run_simulations_with_order([1, 1, 1, 1], [[0, 0], [0, 1], [1, 1], [1, 0], [2, 1], [2, 0], [3, 1], [3, 0]])

# 收割两次蓝色
run_simulations_with_order([1, 1, 1, 1], [[0, 0], [1, 0], [0, 1], [1, 1], [2, 1], [2, 0], [3, 1], [3, 0]])

# 收割三次蓝色
run_simulations_with_order([1, 1, 1, 1], [[0, 0], [1, 0], [2, 0], [0, 1], [1, 1], [2, 1], [3, 1], [3, 0]])

# 蓝蓝，蓝蓝，蓝黄，蓝黄
# 优先升级，确保至少收割一个黄色

# All possible harvests with 5 crops: [0, 0, 0, 0, 0], [0, 0, 0, 0, 1], [0, 0, 0, 0, 2], [0, 0, 0, 1, 1], [0, 0, 0, 1, 2]...

run_simulations_with_order([0, 0, 0, 1, 2], [[0, 0], [0, 1], [1, 0], [1, 1], [2, 0], [2, 1], [3, 0], [3, 1], [4, 0], [4, 1]])

run_simulations_with_order([0, 0, 0, 1, 2], [[0, 0], [0, 1], [1, 0], [1, 1], [2, 0], [2, 1], [3, 1], [3, 0], [4, 0], [4, 1]])

# 蓝蓝，蓝蓝， 蓝蓝，蓝黄，黄黄
# 确保至少收割两个黄色