# -*- coding: utf-8 -*-
"""Path of Exile Harvest.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/16sh0letc6Gbib4qZ3zMYTkbopF0KkkUJ
"""

# Settings

from enum import Enum
from scipy.stats import norm
import numpy as np
import random
import matplotlib.pyplot as plt


ENABLE_DEBUG = False

ENABLE_CROP_ROTATION = True

class PlotColor(Enum):
    YELLOW = 0
    BLUE = 1
    PURPLE = 2

# Lifeforce market price per Chaos
YELLOW_LIFEFORCE_VALUE = 1/23
BLUE_LIFEFORCE_VALUE = 1/62
PURPLE_LIFEFORCE_VALUE = 1/67

# Probability of upgrading the seed from T1 to T2, T2 to T3, T3 to T4
T1_UPGRADE_PROB = 0.25
T2_UPGRADE_PROB = 0.2
T3_UPGRADE_PROB = 0.03

# T2 T3 T4 seeds generation follows binomial distribution if crop rotation is disabled
# LOW CONFIDNECE
T2_GEN_BINOMIAL_N = 8
T2_GEN_BINOMIAL_P = 0.75
T3_GEN_BINOMIAL_N = 3
T3_GEN_BINOMIAL_P = 0.25 * 1.1 # Atlas passives of “Harvest Crops in your Maps have 10% increased chance to contain Tier 3 Plants”
T4_GEN_BINOMIAL_N = 1
T4_GEN_BINOMIAL_P = 0.01 * 1.6 # Atlas passives of “Harvest Crops in your Maps have 60% increased chance to contain Tier 4 Plants”

# Lifefore drop rate from T1, T2, etc. monsters
T1_DROP_RATE = 0.02
T2_DROP_RATE = 0.1
T3_DROP_RATE = 1
T4_DROP_RATE = 1

# Lifefore amount from T1, T2, etc. monsters
T1_DROP_AMOUNT = 7.25
T2_DROP_AMOUNT = 18.5
T3_DROP_AMOUNT = 47
T4_DROP_AMOUNT = 230

# Seed to value map based on the information above
T1_VALUE_MAP = {
    PlotColor.YELLOW: T1_DROP_RATE * T1_DROP_AMOUNT * YELLOW_LIFEFORCE_VALUE,
    PlotColor.BLUE: T1_DROP_RATE * T1_DROP_AMOUNT * BLUE_LIFEFORCE_VALUE,
    PlotColor.PURPLE: T1_DROP_RATE * T1_DROP_AMOUNT * PURPLE_LIFEFORCE_VALUE,
}

T2_VALUE_MAP = {
    PlotColor.YELLOW: T2_DROP_RATE * T2_DROP_AMOUNT * YELLOW_LIFEFORCE_VALUE,
    PlotColor.BLUE: T2_DROP_RATE * T2_DROP_AMOUNT * BLUE_LIFEFORCE_VALUE,
    PlotColor.PURPLE: T2_DROP_RATE * T2_DROP_AMOUNT * PURPLE_LIFEFORCE_VALUE,
}

T3_VALUE_MAP = {
    PlotColor.YELLOW: T3_DROP_RATE * T3_DROP_AMOUNT * YELLOW_LIFEFORCE_VALUE,
    PlotColor.BLUE: T3_DROP_RATE * T3_DROP_AMOUNT * BLUE_LIFEFORCE_VALUE,
    PlotColor.PURPLE: T3_DROP_RATE * T3_DROP_AMOUNT * PURPLE_LIFEFORCE_VALUE,
}

T4_VALUE_MAP = {
    PlotColor.YELLOW: T4_DROP_RATE * T4_DROP_AMOUNT * YELLOW_LIFEFORCE_VALUE,
    PlotColor.BLUE: T4_DROP_RATE * T4_DROP_AMOUNT * BLUE_LIFEFORCE_VALUE,
    PlotColor.PURPLE: T4_DROP_RATE * T4_DROP_AMOUNT * PURPLE_LIFEFORCE_VALUE,
}

# Weight of generating 3, 4, or 5 crops in the harvest
THREE_CROPS_WEIGHT = 0.3
FOUR_CROPS_WEIGHT = 0.5
FIVE_CROPS_WEIGHT = 0.2

# Probability of wilting
PLANT_WILT_PROB = 0.4

# Weight of generating yellow, blue or purple seeds in the plot
YELLOW_SEED_WEIGHT = 1
BLUE_SEED_WEIGHT = 0.55
PURPLE_SEED_WEIGHT = 0.55

# Simulation of harvest

class Plot:
    def __init__(self, color: PlotColor, t1_count, t2_count, t3_count, t4_count):
        self.color: PlotColor = color
        self.t1_count = t1_count
        self.t2_count = t2_count
        self.t3_count = t3_count
        self.t4_count = t4_count

        self.total_value = self.get_total_value()

    def get_total_value(self):
        return T1_VALUE_MAP[self.color] * self.t1_count + T2_VALUE_MAP[self.color] * self.t2_count + T3_VALUE_MAP[self.color] * self.t3_count + T4_VALUE_MAP[self.color] * self.t4_count

    def print_debug(self):
        print(f"color: {self.color}, t1_count: {self.t1_count}, t2_count: {self.t2_count}, t3_count: {self.t3_count}, t4_count: {self.t4_count}, total_value: {self.total_value}")

class Crop:
    def __init__(self, plots: list[Plot]):
        self.plots: list[Plot] = plots

class Harvest:
    def __init__(self, crops: list[Crop]):
        self.crops: list[Crop] = crops
        self.total_crop_count: int = len(crops)

    def simulate_harvest(self, harvest_order: list[list[int]]):
        # [[0,0], [0,1], [1,1], [1,0], [2,0], [2,1]]
        total_return = 0
        crop_harvested = []

        for harvest_step_i in range(len(harvest_order)):
            plot_to_harvest_id = harvest_order[harvest_step_i]

            # If current harvest step is None, it means the plot here is wilted, skip
            if plot_to_harvest_id == None or len(plot_to_harvest_id) != 2:
                continue

            # Harvest, add value to total return
            plot_to_harvest = self.crops[plot_to_harvest_id[0]].plots[plot_to_harvest_id[1]]
            harvest_value = plot_to_harvest.total_value
            total_return += harvest_value
            if ENABLE_DEBUG:
                print("==============================")
                print(f"{plot_to_harvest_id} is harvested, added {harvest_value} return")

            # Simulate if the pair plot will wilt. If so remove the pair plot from the harvest order (set to None)
            is_pair_plot_wilted = plot_wilt_simulated()
            if is_pair_plot_wilted:
                for wilt_step_i in range(harvest_step_i + 1, len(harvest_order)):
                    if harvest_order[wilt_step_i] != None and harvest_order[wilt_step_i][0] == plot_to_harvest_id[0]:
                        harvest_order[wilt_step_i] = None
                        if ENABLE_DEBUG:
                            print(f"pair plot wilted, new harvest order: {harvest_order}")

            # If crop rotation is disabled, seeds will not be upgraded
            if not ENABLE_CROP_ROTATION:
                continue

            # Upgrade all other different color plots left
            for plot_upgrade_i in range(harvest_step_i, len(harvest_order)):
                plot_to_upgrade_id = harvest_order[plot_upgrade_i]
                if plot_to_upgrade_id == None or len(plot_to_upgrade_id) != 2:
                    continue

                if self.crops[plot_to_upgrade_id[0]].plots[plot_to_upgrade_id[1]].color != plot_to_harvest.color:
                    self.crops[plot_to_upgrade_id[0]].plots[plot_to_upgrade_id[1]] = plot_upgrade_simulated(self.crops[plot_to_upgrade_id[0]].plots[plot_to_upgrade_id[1]])
                    if ENABLE_DEBUG:
                        print(f"crops {plot_to_upgrade_id} upgraded")
                        self.crops[plot_to_upgrade_id[0]].plots[plot_to_upgrade_id[1]].print_debug()

        if ENABLE_DEBUG:
            print(f"total return: {total_return}")
        return total_return

    def print_debug(self):
        print(f"total_crop_count: {self.total_crop_count}")
        for i in range(self.total_crop_count):
            print(f"crop {i}:")
            self.crops[i].plots[0].print_debug()
            self.crops[i].plots[1].print_debug()

def plot_upgrade_simulated(old_plot: Plot) -> Plot:
    t1_to_t2_count = np.random.binomial(old_plot.t1_count, T1_UPGRADE_PROB)
    t2_to_t3_count = np.random.binomial(old_plot.t2_count, T2_UPGRADE_PROB)
    t3_to_t4_count = np.random.binomial(old_plot.t3_count, T3_UPGRADE_PROB)

    new_plot = Plot(old_plot.color, old_plot.t1_count - t1_to_t2_count, old_plot.t2_count + t1_to_t2_count - t2_to_t3_count, old_plot.t3_count + t2_to_t3_count - t3_to_t4_count, old_plot.t4_count + t3_to_t4_count)
    return new_plot

def plot_upgrade_expected(old_plot: Plot) -> Plot:
    t1_to_t2_count = old_plot.t1_count * T1_UPGRADE_PROB
    t2_to_t3_count = old_plot.t2_count * T2_UPGRADE_PROB
    t3_to_t4_count = old_plot.t3_count * T3_UPGRADE_PROB

    new_plot = Plot(old_plot.color, old_plot.t1_count - t1_to_t2_count, old_plot.t2_count + t1_to_t2_count - t2_to_t3_count, old_plot.t3_count + t2_to_t3_count - t3_to_t4_count, old_plot.t4_count + t3_to_t4_count)
    return new_plot

def plot_wilt_simulated() -> bool:
    return random.choices([1, 0], weights=[PLANT_WILT_PROB, 1 - PLANT_WILT_PROB])[0] == 1

# Generation of the sacred grove and harvest order

def generate_plot() -> Plot:
    seed_color = random.choices([PlotColor.YELLOW, PlotColor.BLUE, PlotColor.PURPLE], weights=[YELLOW_SEED_WEIGHT, BLUE_SEED_WEIGHT, PURPLE_SEED_WEIGHT])[0]

    # Only T1 seeds will be generated if crop rotation is enabled
    if ENABLE_CROP_ROTATION:
        return Plot(seed_color, 23, 0, 0, 0)

    t2_count = np.random.binomial(T2_GEN_BINOMIAL_N, T2_GEN_BINOMIAL_P)
    t3_count = np.random.binomial(T3_GEN_BINOMIAL_N, T3_GEN_BINOMIAL_P)
    t4_count = np.random.binomial(T4_GEN_BINOMIAL_N, T4_GEN_BINOMIAL_P)
    t1_count = 23 - t2_count - t3_count - t4_count
    return Plot(seed_color, t1_count, t2_count, t3_count, t4_count)


def generate_harvest() -> Harvest:
    # Generate crops
    crops_num = random.choices([3, 4, 5], weights=[THREE_CROPS_WEIGHT, FOUR_CROPS_WEIGHT, FIVE_CROPS_WEIGHT])[0]

    harvest = []
    # For each crop, generate the plots
    for i in range(crops_num):
        plot1 = generate_plot()
        plot2 = generate_plot()
        crop = Crop([plot1, plot2])
        harvest.append(crop)

    return Harvest(harvest)

def generate_harvest_order(harvest: Harvest) -> list[list[int]]:
    harvest_order = []

    # Map is generated randomly so the harvest order can be fixed [[0,0], [0,1], [1,0], [1,1], [2,0], [2,1], ...]
    for i in range(harvest.total_crop_count):
        harvest_order.append([i, 0])
        harvest_order.append([i, 1])
    return harvest_order

ENABLE_DEBUG = False

# Human can choose better harvest order so p15 (percentile 15%) data (worst map, worst harvest order) should not happen in real world
# Simply discard the values that fall below p15
# NOT THE BEST SOLUTION
ENABLE_CROP_ROTATION_COMPENSTAE = True

# Probability of wilting
PLANT_WILT_PROB = 0.4

# Lifeforce market price per Chaos
YELLOW_LIFEFORCE_VALUE = 1/23
BLUE_LIFEFORCE_VALUE = 1/62
PURPLE_LIFEFORCE_VALUE = 1/67

# Weight of generating yellow, blue or purple seeds in the plot
YELLOW_SEED_WEIGHT = 1
BLUE_SEED_WEIGHT = 1
PURPLE_SEED_WEIGHT = 1

ENABLE_CROP_ROTATION = False

# Seed to value map based on the information above
T1_VALUE_MAP = {
    PlotColor.YELLOW: T1_DROP_RATE * T1_DROP_AMOUNT * YELLOW_LIFEFORCE_VALUE,
    PlotColor.BLUE: T1_DROP_RATE * T1_DROP_AMOUNT * BLUE_LIFEFORCE_VALUE,
    PlotColor.PURPLE: T1_DROP_RATE * T1_DROP_AMOUNT * PURPLE_LIFEFORCE_VALUE,
}

T2_VALUE_MAP = {
    PlotColor.YELLOW: T2_DROP_RATE * T2_DROP_AMOUNT * YELLOW_LIFEFORCE_VALUE,
    PlotColor.BLUE: T2_DROP_RATE * T2_DROP_AMOUNT * BLUE_LIFEFORCE_VALUE,
    PlotColor.PURPLE: T2_DROP_RATE * T2_DROP_AMOUNT * PURPLE_LIFEFORCE_VALUE,
}

T3_VALUE_MAP = {
    PlotColor.YELLOW: T3_DROP_RATE * T3_DROP_AMOUNT * YELLOW_LIFEFORCE_VALUE,
    PlotColor.BLUE: T3_DROP_RATE * T3_DROP_AMOUNT * BLUE_LIFEFORCE_VALUE,
    PlotColor.PURPLE: T3_DROP_RATE * T3_DROP_AMOUNT * PURPLE_LIFEFORCE_VALUE,
}

T4_VALUE_MAP = {
    PlotColor.YELLOW: T4_DROP_RATE * T4_DROP_AMOUNT * YELLOW_LIFEFORCE_VALUE,
    PlotColor.BLUE: T4_DROP_RATE * T4_DROP_AMOUNT * BLUE_LIFEFORCE_VALUE,
    PlotColor.PURPLE: T4_DROP_RATE * T4_DROP_AMOUNT * PURPLE_LIFEFORCE_VALUE,
}

value_result = []

for i in range(100000):
    harvest = generate_harvest()
    harvest_order = generate_harvest_order(harvest)
    value = harvest.simulate_harvest(harvest_order)
    value_result.append(value)

if ENABLE_CROP_ROTATION and ENABLE_CROP_ROTATION_COMPENSTAE:
    p15 = np.percentile(value_result, 15)
    value_result = [x for x in value_result if x >= p15]

mu, std = norm.fit(value_result)
print(f"mu: {mu}, std: {std}")

plt.hist(value_result, bins=25, density=True, alpha=0.6, color='b')
xmin, xmax = plt.xlim()
x = np.linspace(xmin, xmax, 100)
p = norm.pdf(x, mu, std)
plt.plot(x, p, 'k', linewidth=2)
title = "Fit results: mu = %.2f,  std = %.2f" % (mu, std)
plt.title(title)

plt.show()